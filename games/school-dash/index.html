<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LM School Dash ‚Äî Playable 3D</title>
  <style>
    :root {
      --lm-pink: #ff66cc;
      --lm-purple: #a066ff;
      --lm-dark: #0b0011;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      height: 100%;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1a0029, #000);
      color: white;
      overflow: hidden;
    }

    .app {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    
    .home-link {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 16px;
      background: rgba(15, 0, 30, 0.55);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      color: white;
      text-decoration: none;
      font-weight: 600;
      z-index: 100;
      transition: all 0.3s;
    }

    .home-link:hover {
      background: rgba(255, 102, 204, 0.3);
      border-color: var(--lm-pink);
      transform: translateY(-2px);
    }
    
    /* Left sidebar with glassmorphism */
    .sidebar {
      width: 26%;
      min-width: 280px;
      color: #fff;
      padding: 40px 30px;
      background: rgba(15, 0, 30, 0.55);
      backdrop-filter: blur(14px);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .logo {
      width: 68px;
      height: 68px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background: linear-gradient(145deg, var(--lm-pink), var(--lm-purple));
      box-shadow: 0 6px 20px rgba(255, 102, 204, 0.4), inset 0 0 18px rgba(255, 255, 255, 0.25);
    }

    .logo span {
      font-size: 2.5rem;
    }

    .title h1 {
      margin: 0;
      font-size: 28px;
      background: linear-gradient(90deg, var(--lm-pink), var(--lm-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .title small {
      opacity: 0.7;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 0.7rem;
    }

    /* Stats cards */
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 16px 18px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 8px 24px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(10px);
    }

    .label {
      font-size: 0.72rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .value {
      margin-top: 6px;
      font-size: 1.6rem;
      font-weight: 800;
      background: linear-gradient(90deg, var(--lm-pink), var(--lm-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Controls list */
    .controls {
      margin-top: 8px;
    }

    .controls h3 {
      margin: 0 0 10px;
      font-size: 0.9rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      opacity: 0.85;
    }

    .controls ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 8px;
    }

    .controls li {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.95rem;
      opacity: 0.95;
    }

    .kbd {
      font: 600 0.85rem ui-monospace, Consolas, Menlo, monospace;
      background: rgba(255, 255, 255, 0.08);
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    /* LM-themed buttons */
    .actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    button {
      flex: 1;
      background: linear-gradient(135deg, var(--lm-pink), var(--lm-purple));
      padding: 12px 22px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      color: white;
      font-weight: 600;
      letter-spacing: 1px;
      transition: 0.3s;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    button:hover {
      filter: brightness(1.2);
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(255, 102, 204, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .hint {
      margin-top: auto;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(255, 102, 204, 0.6);
      text-align: center;
      font-size: 0.78rem;
      animation: blink 1.6s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.25; }
    }

    /* Right world canvas */
    .world {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    /* XP pill in top-right */
    .xp-pill {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 102, 204, 0.25);
      border: 1px solid var(--lm-pink);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 999px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 2;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 102, 204, 0.3);
      animation: glow-pulse 2s ease-in-out infinite;
    }

    @keyframes glow-pulse {
      0%, 100% {
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 102, 204, 0.3);
      }
      50% {
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3), 0 0 30px rgba(255, 102, 204, 0.6);
      }
    }

    .xp-orb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffd3e7, var(--lm-pink) 45%, var(--lm-purple) 75%);
      box-shadow: 0 0 10px var(--lm-pink);
    }

    .lives-pill {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(160, 102, 255, 0.25);
      border: 1px solid var(--lm-purple);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 999px;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 2;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    }

    #worldMount {
      position: absolute;
      inset: 0;
    }

    /* Pause overlay */
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: #fff;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.04em;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      background: linear-gradient(90deg, var(--lm-pink), var(--lm-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay.show {
      opacity: 1;
      background: rgba(0, 0, 0, 0.85);
      -webkit-text-fill-color: white;
    }
  </style>
</head>
<body>
  <a href="../../index.html" class="home-link">üè† Back to Hub</a>
  
  <div class="app">
    <aside class="sidebar">
      <div class="brand">
        <div class="logo">
          <span>üîÆ</span>
        </div>
        <div class="title">
          <h1>LM School Dash</h1>
          <small>Official Playable ‚Ä¢ 3D</small>
        </div>
      </div>

      <div class="stats">
        <div class="card">
          <div class="label">XP</div>
          <div class="value" id="xp">0000</div>
        </div>
        <div class="card">
          <div class="label">Time</div>
          <div class="value" id="time">00:00</div>
        </div>
      </div>

      <div class="controls">
        <h3>Controls</h3>
        <ul>
          <li><span class="kbd">‚Üë / Space</span> <span>Jump</span></li>
          <li><span class="kbd">‚Üì / S</span> <span>Slide</span></li>
          <li><span class="kbd">‚Üê / A</span> <span>Move Left</span></li>
          <li><span class="kbd">‚Üí / D</span> <span>Move Right</span></li>
          <li><span class="kbd">P</span> <span>Pause</span></li>
        </ul>
      </div>

      <div class="actions">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnReset">Reset</button>
      </div>

      <div class="hint" id="hint">Press any key to start</div>
    </aside>

    <main class="world">
      <div class="xp-pill">
        <div class="xp-orb"></div>
        <span id="xpCounter">0 XP</span>
      </div>
      <div class="lives-pill">
        <span>‚ù§Ô∏è</span>
        <span id="lives">x3</span>
      </div>
      <div id="worldMount"></div>
      <div class="overlay" id="pauseOverlay">Paused</div>
    </main>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

  <script>
    // ======= UI Elements =======
    const xpEl = document.getElementById('xp');
    const xpCounter = document.getElementById('xpCounter');
    const timeEl = document.getElementById('time');
    const livesEl = document.getElementById('lives');
    const hint = document.getElementById('hint');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const worldMount = document.getElementById('worldMount');

    // ======= Game State =======
    const LANES = [-2, 0, 2];
    let currentLaneIndex = 1;
    let speed = 0.2;
    let running = false;
    let paused = false;
    let seconds = 0, xp = 0, lives = 3;
    let invulnTime = 0;

    // ======= Three.js Setup =======
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    worldMount.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050010, 0.06);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
    camera.position.set(0, 2, 6);

    // LM-themed lighting
    const ambient = new THREE.AmbientLight(0xff66cc, 0.7);
    scene.add(ambient);

    const purpleLight = new THREE.PointLight(0xa066ff, 2, 50);
    purpleLight.position.set(0, 10, 0);
    scene.add(purpleLight);

    const pinkLight = new THREE.PointLight(0xff66cc, 1.5, 40);
    pinkLight.position.set(0, 5, -10);
    scene.add(pinkLight);

    // Floor & walls with LM colors
    const segments = [];
    const SEG_LEN = 8;
    const SEG_COUNT = 6;

    const floorMat = new THREE.MeshStandardMaterial({ 
      color: 0x300025,
      metalness: 0.3, 
      roughness: 0.5,
      emissive: 0x1a0015,
      emissiveIntensity: 0.2
    });
    const wallMatL = new THREE.MeshStandardMaterial({ 
      color: 0x180018,
      metalness: 0.3, 
      roughness: 0.6 
    });
    const wallMatR = new THREE.MeshStandardMaterial({ 
      color: 0x180018,
      metalness: 0.3, 
      roughness: 0.6 
    });

    function makeSegment(z) {
      const group = new THREE.Group();
      // floor
      const floor = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, SEG_LEN), floorMat);
      floor.position.set(0, -0.05, 0);
      floor.receiveShadow = true;
      group.add(floor);
      // left wall
      const wallL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 3, SEG_LEN), wallMatL);
      wallL.position.set(-4, 1.4, 0);
      group.add(wallL);
      // right wall
      const wallR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 3, SEG_LEN), wallMatR);
      wallR.position.set(4, 1.4, 0);
      group.add(wallR);

      group.position.z = z;
      scene.add(group);
      return group;
    }
    for (let i = 0; i < SEG_COUNT; i++) {
      segments.push(makeSegment(-i * SEG_LEN));
    }

    // LM Player model: sphere with horns
    const LM = new THREE.Group();
    
    const geometry = new THREE.SphereGeometry(1.1, 32, 32);
    const material = new THREE.MeshStandardMaterial({
      color: 0xff66cc,
      emissive: 0xa066ff,
      emissiveIntensity: 0.4,
      roughness: 0.4,
      metalness: 0.2
    });
    
    const body = new THREE.Mesh(geometry, material);
    LM.add(body);
    
    // Little LM horns
    const hornGeo = new THREE.ConeGeometry(0.3, 0.5, 16);
    const hornMat = new THREE.MeshStandardMaterial({ 
      color: 0xffffff,
      emissive: 0xff66cc,
      emissiveIntensity: 0.2
    });
    
    const horn1 = new THREE.Mesh(hornGeo, hornMat);
    horn1.position.set(0.4, 1, -0.2);
    horn1.rotation.z = 0.4;
    LM.add(horn1);
    
    const horn2 = horn1.clone();
    horn2.position.x = -0.4;
    horn2.rotation.z = -0.4;
    LM.add(horn2);
    
    LM.position.set(LANES[currentLaneIndex], 0.9, 0);
    scene.add(LM);

    // XP orbs
    const orbs = [];
    const orbGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const orbMat = new THREE.MeshStandardMaterial({ 
      color: 0xff77bb, 
      emissive: 0xff66cc, 
      emissiveIntensity: 0.8, 
      metalness: 0.2, 
      roughness: 0.3 
    });

    // Obstacles
    const obstacles = [];
    function spawnObstacle() {
      const lane = LANES[Math.floor(Math.random() * 3)];
      const type = Math.random() < 0.5 ? 'desk' : 'locker';
      let mesh;
      if (type === 'desk') {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 0.8),
          new THREE.MeshStandardMaterial({ 
            color: 0x8b5a2b, 
            metalness: 0.1, 
            roughness: 0.8 
          }));
        mesh.userData.action = 'jump';
      } else {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.8, 1.0),
          new THREE.MeshStandardMaterial({ 
            color: 0x4a2d8f, 
            metalness: 0.4, 
            roughness: 0.5,
            emissive: 0xa066ff,
            emissiveIntensity: 0.1
          }));
        mesh.userData.action = 'side';
      }
      mesh.position.set(lane, mesh.geometry.parameters.height / 2, -40);
      mesh.userData.type = type;
      obstacles.push(mesh);
      scene.add(mesh);
    }

    function spawnOrb() {
      const lane = LANES[Math.floor(Math.random() * 3)];
      const orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(lane, 1.2, -40);
      orbs.push(orb);
      scene.add(orb);
    }

    // Input handling
    let targetX = LANES[currentLaneIndex];
    let jumping = false, sliding = false;
    let jumpT = 0, slideT = 0;

    function moveLeft() { 
      currentLaneIndex = Math.max(0, currentLaneIndex - 1); 
      targetX = LANES[currentLaneIndex]; 
    }
    function moveRight() { 
      currentLaneIndex = Math.min(2, currentLaneIndex + 1); 
      targetX = LANES[currentLaneIndex]; 
    }
    function jump() {
      if (jumping || sliding) return;
      jumping = true; 
      jumpT = 0;
    }
    function slide() {
      if (jumping || sliding) return;
      sliding = true; 
      slideT = 0;
    }

    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (!running) startGame();
      if (k === 'arrowleft' || k === 'a') moveLeft();
      if (k === 'arrowright' || k === 'd') moveRight();
      if (k === 'arrowup' || k === ' ') jump();
      if (k === 'arrowdown' || k === 's') slide();
      if (k === 'p') togglePause();
    });

    // UI buttons
    btnStart.addEventListener('click', () => startGame());
    btnPause.addEventListener('click', () => togglePause());
    btnReset.addEventListener('click', () => resetGame());

    function updateUI() {
      xpEl.textContent = String(xp).padStart(4, '0');
      xpCounter.textContent = xp + ' XP';
      timeEl.textContent = formatTime(seconds);
      livesEl.textContent = 'x' + lives;
    }
    
    function formatTime(s) {
      const m = Math.floor(s / 60).toString().padStart(2, '0');
      const r = (s % 60).toString().padStart(2, '0');
      return m + ':' + r;
    }

    // Resize
    function resize() {
      const rect = worldMount.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    // Timers
    let lastTime = performance.now();
    let spawnTimer = 0;
    let orbTimer = 0;
    let secondTick = 0;

    function startGame() {
      if (running && !paused) return;
      if (!running) {
        seconds = 0; 
        xp = 0; 
        speed = 0.2; 
        lives = 3;
        clearAll();
      }
      running = true; 
      paused = false; 
      hint.style.opacity = 0;
      pauseOverlay.classList.remove('show');
    }
    
    function togglePause() {
      if (!running) return;
      paused = !paused;
      pauseOverlay.classList.toggle('show', paused);
    }
    
    function resetGame() {
      running = false; 
      paused = false; 
      hint.style.opacity = 1;
      pauseOverlay.classList.remove('show');
      seconds = 0; 
      xp = 0; 
      lives = 3; 
      speed = 0.2;
      invulnTime = 0;
      clearAll();
      updateUI();
    }

    function clearAll() {
      obstacles.forEach(o => scene.remove(o)); 
      obstacles.length = 0;
      orbs.forEach(o => scene.remove(o)); 
      orbs.length = 0;
      segments.forEach((seg, i) => seg.position.z = -i * SEG_LEN);
      currentLaneIndex = 1; 
      targetX = LANES[currentLaneIndex];
      LM.position.set(targetX, 0.9, 0);
      LM.scale.set(1, 1, 1);
      jumping = sliding = false;
    }

    // Collision helpers
    function aabbIntersect(a, b) {
      a.traverse(node => {
        if (node.geometry) node.geometry.computeBoundingBox();
      });
      b.geometry.computeBoundingBox();
      a.updateMatrixWorld(); 
      b.updateMatrixWorld();
      
      const aBox = new THREE.Box3().setFromObject(a);
      const bBox = b.geometry.boundingBox.clone().applyMatrix4(b.matrixWorld);
      
      return aBox.intersectsBox(bBox);
    }

    // Game loop
    function loop(now) {
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      
      if (!running || paused) { 
        renderer.render(scene, camera); 
        return; 
      }

      // Smooth lane switch
      LM.position.x += (targetX - LM.position.x) * Math.min(1, 10 * dt);

      // LM glow pulse animation
      body.material.emissiveIntensity = 0.4 + Math.sin(now * 0.003) * 0.15;

      // Jump
      if (jumping) {
        jumpT += dt * 2;
        const h = Math.sin(Math.PI * Math.min(1, jumpT)) * 1.5;
        LM.position.y = 0.9 + h;
        if (jumpT >= 1) { 
          jumping = false; 
          LM.position.y = 0.9; 
        }
      }

      // Slide
      if (sliding) {
        slideT += dt * 2;
        LM.scale.y = 1 - 0.35 * Math.min(1, slideT * 2);
        if (slideT >= 1) { 
          sliding = false; 
          LM.scale.y = 1; 
        }
      }

      // Rotate LM slightly for animation
      LM.rotation.y += dt * 0.5;

      // Move hallway segments
      for (let seg of segments) {
        seg.position.z += speed;
        if (seg.position.z > SEG_LEN) {
          seg.position.z -= SEG_COUNT * SEG_LEN;
        }
      }

      // Spawn logic
      spawnTimer += dt;
      orbTimer += dt;
      secondTick += dt;
      if (spawnTimer > Math.max(0.7, 1.4 - speed)) { 
        spawnTimer = 0; 
        spawnObstacle(); 
      }
      if (orbTimer > 1.2) { 
        orbTimer = 0; 
        spawnOrb(); 
      }
      if (secondTick > 1) { 
        secondTick = 0; 
        seconds++; 
        xp += 1; 
        speed = Math.min(0.6, speed + 0.005); 
        updateUI(); 
      }

      // Move obstacles/orbs
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.position.z += speed * 3.2;
        o.rotation.y += dt;
        
        if (o.position.z > -0.5 && o.position.z < 1.5) {
          if (aabbIntersect(LM, o) && invulnTime <= 0) {
            const needed = o.userData.action;
            const correct = (needed === 'jump' && jumping) ||
                          (needed === 'side' && Math.abs(LM.position.x - o.position.x) > 0.1);
            if (!correct) {
              lives--;
              invulnTime = 1.2;
              body.material.emissiveIntensity = 1.0;
              if (lives <= 0) { 
                gameOver(); 
              }
              updateUI();
            } else {
              xp += 5; 
              updateUI();
            }
          }
        }
        if (o.position.z > 6) {
          scene.remove(o); 
          obstacles.splice(i, 1);
        }
      }

      // Orbs collection
      for (let i = orbs.length - 1; i >= 0; i--) {
        const ob = orbs[i];
        ob.position.z += speed * 3.2;
        ob.rotation.y += dt * 2;
        
        if (ob.position.z > -0.5 && aabbIntersect(LM, ob)) {
          xp += 10; 
          updateUI();
          scene.remove(ob); 
          orbs.splice(i, 1);
        } else if (ob.position.z > 6) {
          scene.remove(ob); 
          orbs.splice(i, 1);
        }
      }

      // Invulnerability flicker
      if (invulnTime > 0) {
        invulnTime -= dt;
        LM.visible = Math.floor(invulnTime * 20) % 2 === 0;
        if (invulnTime <= 0) { 
          LM.visible = true; 
          body.material.emissiveIntensity = 0.4; 
        }
      }

      renderer.render(scene, camera);
    }
    requestAnimationFrame(loop);

    function gameOver() {
      running = false; 
      paused = false;
      pauseOverlay.textContent = 'Game Over ‚Äî Reset to Try Again';
      pauseOverlay.classList.add('show');
    }

    updateUI();
    resize();
  </script>
</body>
</html>
